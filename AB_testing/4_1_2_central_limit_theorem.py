# -*- coding: utf-8 -*-
"""4.1.2_central-limit-theorem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11rKT1URWEl9qOLooPHzmZVBy0FRwTw-V

# Central Limit Theorem
The Central Limit Theorem (CLT) is a fundamental concept in the field of statistics. It states that, regardless of the population distribution, as long as the sample size is sufficiently large, the distribution of the sample means will approximate a normal distribution. This powerful theorem is a cornerstone of statistical inference, enabling analysts and researchers to make robust inferences about a population based on the properties of sample data.

In this notebook, we'll explore each facet of the Central Limit Theorem. We'll delve into the process of sampling, calculating sample means, and understanding distributions. Then, we'll assemble these components to construct the distribution of sample means. This will show how the distribution of sample means closely approximates a normal distribution.

---
## 1.&nbsp; Import libraries üíæ
"""

import pandas as pd
import random
import numpy as np
import matplotlib.pyplot as plt

"""---
## 2.&nbsp; Creating a population and taking samples üßë‚Äçü§ù‚Äçüßë
In this notebook, we require a population from which we can draw samples. Our chosen population consists of 100,000 randomly generated numbers ranging from one to one hundred. These numbers can be thought of as representing the ages of the population residing in WBS City.

"""

population_list = []

for _ in range(100000):
  population_list.append(random.randint(1, 100))

"""Let's take a look at the first 10 numbers to verify they are random numbers between 1 and 100."""

population_list[:10]

"""Fantastic! Next, we'll convert this list into a pandas Series, allowing us to take advantage of the `.sample()` method."""

population_series = pd.Series(population_list)

"""In this experiment, we intend to take numerous samples from our population and record the mean of each sample. To ensure that each sample has an equal opportunity, we must ensure that each sample is put back into the population rather than removed from it. By default, Pandas sets the `replace` parameter to `False`, which implies that once a sample is taken, it is removed from the population. With multiple samples, this would result in a progressively shrinking population. Our goal is for each sample to be drawn from the entire population, so we must adjust this parameter to `True`.

"""

# While 20 is small for a sample size, we limit it to keep this notebook concise.
sample_size = 20

population_series.sample(n = sample_size, replace = True)

"""The first column represents the indexes, while the second column contains the "ages," which are the random numbers we generated.

---
## 3.&nbsp; Sample means üîç
When we talk about sample means, we're actually referring to the means of multiple samples (hence the plural üòâ). Here's how it works: We start by taking a sample from our population, calculate the mean of that sample, and record it in a list. We then repeat this process, taking more samples from our population, calculating the means for each sample, and adding these means to our list.

Let's start by initialising an empty list where we'll store the means of the many samples we'll be collecting.
"""

sample_means = []

"""Next, let's add our first sample mean to the list. We'll also increase the sample size - larger sample sizes tend to provide more accurate representations of the entire population."""

# Increase sample_size
sample_size = 200

# Generate a random sample from the population_series.
first_sample = population_series.sample(n=sample_size, replace=True)

# Calculate the mean of the first_sample.
first_sample_mean = first_sample.mean()

# Append the mean of the first_sample to the 'sample_means' list.
sample_means.append(first_sample_mean)

# Display the updated 'sample_means' list.
sample_means

"""### Challenge 1:
That was easy, right! Now our task is to replicate this process multiple times. We will repeatedly take samples, calculate their means, and store those means in our sample_means list. Utilise your understanding of for loops to add the means of 10,000 more samples to the sample_means list.

"""

# Define the number of additional samples you want to collect
num_samples = 10001 - len(sample_means)

# Loop to collect more samples
for _ in range(num_samples):

    # Generate a random sample from the population_series
    sample = population_series.sample(n=sample_size, replace=True)

    # Calculate the mean of the first_sample
    sample_mean = sample.mean()

    # Append the mean of the first_sample to the 'sample_means' list
    sample_means.append(sample_mean)

    # Display the updated 'sample_means' list.

sample_means[-10:]

len(sample_means)

"""---
## 4.&nbsp; Distribution üìä
Distributions are graphical or mathematical representations that illustrate how data points are spread across a dataset. These representations enable us to comprehend the frequency and positioning of data within the dataset, shedding light on the likelihood of encountering specific values or events.

We've actually come across visual distributions before, although you might not have recognised them as such. Histograms are an example of distributions. They display values on the x-axis and the frequency of each value on the y-axis.

Let's look at the distribution of ages in our population_series.
"""

# Create the histogram using Matplotlib
plt.hist(population_series, bins=20)  # Added 'bins' for better granularity.

# Add a title and axis labels
plt.title("Age distribution of WBS City")
plt.xlabel("Ages")
plt.ylabel("Frequency")

# Show the histogram
plt.show()

"""The observed distribution may appear somewhat uniform and lacking excitement, which is not unexpected. We specifically requested 100,000 random numbers falling between 1 and 100. Given that each number has an equal probability of being selected, over the course of 100,000 selections, each value has been chosen nearly an equal number of times. This aligns with the law of large numbers.

We can also explore the distribution of our 10,001 sample means by plotting a histogram.
"""

# Create the histogram using Matplotlib
plt.hist(sample_means, bins=50)  # Added 'bins' for better granularity.

# Add a title and axis labels
plt.title("Distribution of the sample means")
plt.xlabel("Mean age of the sample")
plt.ylabel("Frequency")

# Show the histogram
plt.show()

"""This is promising. The distribution of our sample means appears to be approximating a normal distribution - the bell-shaped curve. This aligns with the fundamental insight of the Central Limit Theorem; regardless of the population distribution, as long as the sample size is sufficiently large, the distribution of the sample means will tend to approximate a normal distribution.

And that's it, that's the Central Limit Theorem - when we take many samples, calculate the means of those samples, and plot the distribution of those sample means, we end up with an approximation of the normal distribution.

---
## 5.&nbsp; Challenges üòÉ

### Challenge 2:

Here is the code we used to generate the distribution of sample means. To observe the effects of changing these variables, modify one variable at a time and observe the outcomes.

- **Sample Size:** Adjust the size of individual samples.
- **Number of Samples:** Alter the quantity of samples taken.

Increasing the number of samples taken indeed tends to make the distribution more closely resemble a normal distribution. This observation aligns with the [Law of Large Numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers). Additionally, larger sample sizes result in smaller margins of error and reduced standard deviation, leading to more precise estimates of population parameters.

By systematically adjusting these variables and observing the resulting distribution, you can gain valuable insights into the impact of sample size and sample quantity on the accuracy of statistical estimates.
"""

num_samples = 20000
sample_size = 200

sample_means = []

for _ in range(num_samples):
    sample = population_series.sample(n=sample_size, replace=True)
    sample_mean = sample.mean()
    sample_means.append(sample_mean)

plt.hist(sample_means, bins=50)
plt.title("Distribution of the sample means")
plt.xlabel("Mean age of the sample")
plt.ylabel("Frequency")
plt.show()
pd.Series(sample_means).describe()

"""### Challenge 3:

In this challenge, we will change from the flat and unexciting age distribution of WBS City and explore a bimodal distribution with two distinct peaks. Your task is to perform the experiment again. Follow these steps:

1. Start with the array `ages`, which we've created in the code below for you. These are the ages of the citizens of WBS City 2, as shown in the histogram below.

2. Start the experiment by taking a sample of 250 people from `ages`, calculating the samples mean, and storing this mean in a list.

3. Utilise your for loop skills to repeat the process by taking 30,000 more sample means, and appending them to your list.

4. Finally, create a histogram of your list of sample means and examine the resulting distribution. Does the distribution of sample means for this new and different population also approximate the normal distribution?

"""

# Set the number of data points
num_points = 100000

# Define the parameters for each mode (mean and standard deviation)
modes = [
    {'mean': 30, 'std_dev': 5},
    {'mean': 60, 'std_dev': 10},
    {'mean': 80, 'std_dev': 8}
]

# Generate random numbers for each mode and concatenate them
ages = np.concatenate([np.random.normal(mode['mean'], mode['std_dev'], num_points) for mode in modes])

# Create a histogram to visualise the distribution
plt.hist(ages, bins=30)
plt.title("Age distribution of WBS City 2")
plt.xlabel("Age")
plt.ylabel("Frequency")
plt.show()

# Create a Series for the age data
ages_series = pd.Series(ages)

# Initialise an empty list to store sample means
sample_means_2 = []

# Define the number of samples and sample size
num_samples = 30000
sample_size = 750

# Perform the sampling and mean calculation
for _ in range(num_samples):
    sample = ages_series.sample(n=sample_size, replace=True)
    sample_mean = sample.mean()
    sample_means_2.append(sample_mean)

# Create a histogram of the sample means
plt.hist(sample_means_2, bins=50)
plt.title("Distribution of Sample Means")
plt.xlabel("Mean Age of the Sample")
plt.ylabel("Frequency")
plt.show()
pd.Series(sample_means_2).describe()

"""We introduced a bimodal distribution with two distinct peaks for the ages of citizens in WBS City 2. This population is significantly different from the uniform distribution of WBS City.

Despite the bimodal nature of the population, the distribution of sample means for this new and different population still tends to approximate a normal distribution. The Central Limit Theorem holds true even for populations with complex distributions.
"""